<!-- TODO LIST: -->
<!-- NOTELOCK SYSTEM [] -->
<!-- HIT ANIMATION [WIP] -->
<!-- JUDGING SYSTEM [WIP] -->
<!-- AUDIO PLAYBACK [] -->
<!-- HOLD NOTE SYSTEM []   -->
<!-- 4K MODE -->
<!-- CURSOR NOTE SYSTEM [X] -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor</title>
    <script src="./library/parser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&display=swap" rel="stylesheet">
</head>

<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    canvas {
        display: block;
    }
</style>

<body>
    <div class="slidecontainer">
        <input type="range" min="1" max="5000" value="0" class="slider" id="myRange" style="width:1000px">
    </div>
    <script>
        var offset = 250;
        dat = fetch('/file.dirhythia')
            .then((response) => response.text())
            .then((data) => {
                return data;
            });
        async function start() {
            let chartdata = parse(await dat, offset);
            const app = new PIXI.Application({});
            let cursorcontainer = new PIXI.Container();
            document.body.appendChild(app.view);
            chartdata[0].forEach(element => {
                const stime = element['st'];
                const pos = element['pos'];
                let note = new PIXI.Graphics();
                note.beginFill(0x85b4ff);
                note.drawRect(0, 0, 100, 10);
                var notes = new PIXI.Sprite(app.renderer.generateTexture(note));
                notes.name = element['line'];
                switch (pos) {
                    case 2:
                        notes.anchor.set(0, 0.5);
                        break;
                    case 1:
                        notes.anchor.set(1, 0.5);
                        break;
                    default:
                        break;
                }
                notes.x = 400;
                notes.y = 0;
                app.stage.addChild(notes);
            });
            let cursorx = 400;
            let cursory = 0;
            let cursortime = 0;
            // let lastctime = 0
            let ind = 0;
            chartdata[1].forEach(element => {
                cursortime = element['st'];
                nextc = element['st'];
                if (chartdata[1][ind + 1] != undefined) {
                    nextc = chartdata[1][ind + 1]['st'];
                }
                // cursorcontainer.height += element['st'] * 0.5;
                let note = new PIXI.Graphics();
                note.beginFill(0xffffff);
                note.drawRect(0, 0, element['pos'] - cursorx, 3);
                let cursorr = new PIXI.Graphics();
                cursorr.beginFill(0xffffff);
                cursorr.alpha = 0.5;
                note.alpha = 0.5;
                cursorr.drawRect(0, 0, 3, (cursortime - nextc) * 0.5);
                var notes = new PIXI.Sprite(app.renderer.generateTexture(note));
                var cursorrs = new PIXI.Sprite(app.renderer.generateTexture(cursorr));
                cursorrs.anchor.set(0, 1);
                notes.name = element['line'] + "n";
                cursorrs.name = element['line'] + "c";
                if (element['pos'] > cursorx) {
                    notes.anchor.set(0, 0);
                } else if (element['pos'] < cursorx) {
                    notes.anchor.set(1, 0)
                }
                notes.x = cursorx;
                cursorx = element['pos'];
                cursorrs.x = cursorx;
                notes.y = 0;
                cursorrs.y = 0;
                ind += 1;
                cursory -= element['st'] * 0.5;
                app.stage.addChild(cursorrs);
                app.stage.addChild(notes);
            });
            var curcurx = 400;
            var combo = 0;
            const style = new PIXI.TextStyle({
                fontFamily: 'Montserrat',
                fontSize: 20,
                fontWeight: 'bold',
                fill: '#ffffff'
            });
            let combotexts = new PIXI.Text(combo, style);
            combotexts.x = 400;
            combotexts.alpha = 0.5
            combotexts.y = 550;

            function update(tstamp) {
                combotexts.text = combo;
                chartdata[0].forEach(element => {
                    let stime = element['st'] - 1000;
                    let etime = element['st'];
                    try {
                        app.stage.getChildByName(element['line']).y = (((tstamp - stime) / (etime -
                            stime)) * (
                            500));
                        chartdata[1].forEach(el => {
                            if (el['st'] == etime) {
                                curcurx = el['pos'];
                            }
                        })
                        app.stage.getChildByName(element['line']).x = curcurx;
                    } catch (error) {}
                })
                chartdata[1].forEach(element => {
                    let stime = element['st'] - 1000;
                    let etime = element['st'];
                    app.stage.getChildByName(element['line'] + "c").y = (((tstamp - stime) / (etime -
                        stime)) * (500));
                })
                chartdata[1].forEach(element => {
                    let stime = element['st'] - 1000;
                    let etime = element['st'];
                    app.stage.getChildByName(element['line'] + "n").y = (((tstamp - stime) / (etime -
                        stime)) * (500));
                })
            }
            var realx;
            let curcurxr = 400;
            const blurFilter = new PIXI.filters.BlurFilter();

            function rulesets(timestamp) {
                for (let index = 0; index < chartdata[1].length; index++) {
                    const element = chartdata[1][index];
                    if (timestamp >= element['st'] - 10 && timestamp <= element['st'] + 10) {
                        realx = element['pos'];
                        break;
                    }
                }
                document.onkeydown = function (e) {
                    var keynum = e.key;
                    let ww = 0;
                    chartdata[0].forEach(element => {
                        if (currentstamp <= element['st'] + 200 && currentstamp >= element['st'] -
                            200) {
                            let keyval;
                            switch (element['pos']) {
                                case 1:
                                    keyval = "z";
                                    break;
                                case 2:
                                    keyval = "x";
                                    break
                                default:
                                    break;
                            }
                            if (keynum.includes(keyval)) {
                                let nlst = true
                                for (let ww = 0; ww < chartdata[0].length; ww++) {
                                    const ele = chartdata[0][ww];
                                    if (ele['st'] < element['st']) {
                                        if (!ele['hit']) {
                                            nlst = false;
                                        }
                                    }
                                }
                                if (nlst) {
                                    element['hit'] = true;
                                    combo += 1;
                                }


                            }
                        }
                        ww
                    })
                    chartdata[1].forEach(element => {
                        let keyval;
                        if (currentstamp <= element['st'] + 200 && currentstamp >= element['st'] -
                            200) {
                            if (element['pos'] > curcurxr) {
                                keyval = "ArrowRight"
                            }
                            if (element['pos'] < curcurxr)(
                                keyval = "ArrowLeft"
                            )
                            if (keyval == keynum) {
                                curcurxr = element['pos'];
                                element['hit'] = true;
                                combo += 1;
                            }
                        }
                    })
                };
            }
            app.stage.addChild(cursorcontainer);
            let jline = new PIXI.Graphics();
            jline.beginFill(0xffffff);
            jline.drawRect(0, 0, 800, 2);
            var jlines = new PIXI.Sprite(app.renderer.generateTexture(jline));
            jlines.x = 0;
            jlines.y = 500;
            let cursor1 = new PIXI.Graphics();
            cursor1.beginFill(0xffffff);
            cursor1.drawRect(0, 0, 10, 10);
            var cursor1s = new PIXI.Sprite(app.renderer.generateTexture(cursor1));
            cursor1s.x = 400 - 50;
            cursor1s.anchor.set(0.5);
            cursor1s.angle = 45;
            cursor1s.y = 500;
            var cursor2s = new PIXI.Sprite(app.renderer.generateTexture(cursor1));
            cursor2s.x = 400 + 50;
            cursor2s.anchor.set(0.5);
            cursor2s.angle = 45;
            cursor2s.y = 500;
            app.stage.addChild(jlines);
            app.stage.addChild(cursor1s);
            app.stage.addChild(combotexts);
            app.stage.addChild(cursor2s);
            let started = false;
            let tstarted = NaN;
            let currentstamp = 0;
            const audio = new Audio('./audio.mp3');
            document.getElementById("play").onclick = function () {
                audio.play()
                setInterval(() => {
                    if (audio.paused != true) {
                        let t = new Date().getTime();
                        update(currentstamp);
                        if (started == false) {
                            started = true;
                            tstarted = new Date().getTime();
                        };
                        document.getElementById("myRange").value = (5 * currentstamp) / audio.duration;
                        currentstamp = (new Date().getTime() - tstarted);
                    }
                }, 10);
            };
            document.getElementById("stop").onclick = function () {
                audio.pause();
                audio.currentTime = 0;
                document.getElementById("myRange").value = 0;
                currentstamp = 0;
            };

            audio.onloadedmetadata = function () {
                document.getElementById("myRange").oninput = function () {
                    currentstamp = this.value / 5000 * audio.duration * 1000;
                    update(currentstamp);
                }
            }
        }
        start();
    </script>
    <button id="play">play</button>
    <button id="stop">stop</button>
</body>

</html>